mod combined_connector;
mod native_type_constructor;

pub mod error;
pub mod scalars;

pub use combined_connector::CombinedConnector;
pub use native_type_constructor::NativeTypeConstructor;
use native_types::NativeType;
use serde::de::DeserializeOwned;

pub trait Connector: Send + Sync {
    fn capabilities(&self) -> &Vec<ConnectorCapability>;

    fn has_capability(&self, capability: ConnectorCapability) -> bool {
        self.capabilities().contains(&capability)
    }

    /// Returns all available native type constructors available through this connector.
    /// Powers the auto completion of the vs code plugin.
    fn available_native_type_constructors(&self) -> &Vec<NativeTypeConstructor>;

    fn find_native_type_constructor(&self, name: &str) -> &NativeTypeConstructor {
        self.available_native_type_constructors()
            .iter()
            .find(|constructor| constructor.name.as_str() == name)
            .unwrap()
    }

    // TODO carmen: This should return a Result<NativeTypeInstance, ConnectorError> instead.
    // possible errors: unknown type name, wrong number of arguments, declared field type is not compatible with native type
    /// This function is used during Schema parsing to calculate the concrete native type.
    /// This powers the use of native types for QE + ME.
    fn parse_native_type(&self, name: &str, args: Vec<u32>) -> Option<NativeTypeInstance>;

    // TODO carmen: This should return a Result<NativeTypeInstance, ConnectorError> instead.
    /// This function is used during introspection to turn an introspected native type into an instance that can be put into the Prisma schema.
    /// powers IE
    fn introspect_native_type(&self, native_type: Box<dyn NativeType>) -> Option<NativeTypeInstance>;

    fn supports_scalar_lists(&self) -> bool {
        self.has_capability(ConnectorCapability::ScalarLists)
    }

    fn supports_multiple_indexes_with_same_name(&self) -> bool {
        self.has_capability(ConnectorCapability::MultipleIndexesWithSameName)
    }

    fn supports_relations_over_non_unique_criteria(&self) -> bool {
        self.has_capability(ConnectorCapability::RelationsOverNonUniqueCriteria)
    }

    fn supports_enums(&self) -> bool {
        self.has_capability(ConnectorCapability::Enums)
    }

    fn supports_json(&self) -> bool {
        self.has_capability(ConnectorCapability::Json)
    }

    fn supports_non_id_auto_increment(&self) -> bool {
        self.has_capability(ConnectorCapability::AutoIncrementAllowedOnNonId)
    }

    fn supports_multiple_auto_increment(&self) -> bool {
        self.has_capability(ConnectorCapability::AutoIncrementMultipleAllowed)
    }

    fn supports_non_indexed_auto_increment(&self) -> bool {
        self.has_capability(ConnectorCapability::AutoIncrementNonIndexedAllowed)
    }
}

/// Not all Databases are created equal. Hence connectors for our datasources support different capabilities.
/// These are used during schema validation. E.g. if a connector does not support enums an error will be raised.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ConnectorCapability {
    ScalarLists,
    RelationsOverNonUniqueCriteria,
    MultipleIndexesWithSameName,
    Enums,
    Json,
    AutoIncrementAllowedOnNonId,
    AutoIncrementMultipleAllowed,
    AutoIncrementNonIndexedAllowed,
}

/// represents an instance of a native type declared in the Prisma schema
#[derive(Debug, Clone, PartialEq)]
pub struct NativeTypeInstance {
    /// the name of the native type used in the Prisma schema
    name: String,
    /// the arguments that were provided
    args: Vec<u32>,
    /// the serialized representation of this native type. The serialized format is generated by the `native-types` library
    serialized_native_type: serde_json::Value,
}

impl NativeTypeInstance {
    pub fn new(name: &str, args: Vec<u32>, native_type: &dyn NativeType) -> Self {
        NativeTypeInstance {
            name: name.to_string(),
            args,
            serialized_native_type: native_type.to_json(),
        }
    }

    pub fn deserialize_native_type<T>(&self) -> T
    where
        T: DeserializeOwned,
    {
        let error_msg = format!(
            "Deserializing the native type from json failed: {:?}",
            self.serialized_native_type.as_str()
        );
        serde_json::from_value(self.serialized_native_type.clone()).expect(&error_msg)
    }
}
