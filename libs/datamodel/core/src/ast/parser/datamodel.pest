// ######################################
// Readme
// ######################################
// You will notice the pattern ( X ~ Y | X )
// instead of X ~ Y?. This is because we do not
// want the concat operator ~ between X and Y
// to consume any whitespace after X, if Y is not present.

// ######################################
// Global (builtin) expressions
// ######################################

// Treat every whitespace the same for now.
WHITESPACE = @{ SPACE_SEPARATOR | "\t" }
UNTIL_END_OF_LINE = _{ WHITESPACE* ~ NEWLINE }
// the any part is to not crash on comments next to an open block, see test `parse_comments_without_crasing_or_loosing_info`
BLOCK_OPEN = @{ "{" ~ (!NEWLINE ~ ANY)* ~ UNTIL_END_OF_LINE }
BLOCK_CLOSE = @{ "}" }
MODEL_KEYWORD = @{ "model" }
TYPE_KEYWORD = @{ "type" }
ENUM_KEYWORD = @{ "enum" }
GENERATOR_KEYWORD = @{ "generator" }
DATASOURCE_KEYWORD = @{ "datasource" }

INTERPOLATION_START = { "${" }
INTERPOLATION_END = { "}" }

LEGACY_COLON = { ":" }

CATCH_ALL = @{ (WHITESPACE | LETTER | NUMBER | PUNCTUATION | SYMBOL)* ~ NEWLINE }

doc_content = @{ (!NEWLINE ~ ANY)* }
doc_comment = { "//" ~ doc_content }
doc_comment_and_new_line = ${ doc_comment ~ NEWLINE }

// ######################################
// Base building blocks
// ######################################
maybe_empty_identifier = @{ ( "_" | "-" | ASCII_ALPHANUMERIC)* }
non_empty_identifier = @{ ASCII_ALPHANUMERIC ~ maybe_empty_identifier }
number = @{ ASCII_DIGIT+ }

// Literals
numeric_literal = @{ ("-")? ~ ASCII_DIGIT+ ~("." ~ ASCII_DIGIT+)? }

// String, with support for escaped stuff and interpolations.
string_escaped_predefined = { "n" | "r" | "t" | "\\" | "0" | "\"" | "'" | INTERPOLATION_START }
string_escape     = { "\\" ~ string_escaped_predefined }
// This is only used to escape the parser. The string above is still treated as atomic.
string_interpolate_escape = !{ (INTERPOLATION_START ~ expression ~ INTERPOLATION_END) }
string_raw = { (!("\\" | "\"" | NEWLINE | INTERPOLATION_START ) ~ (ANY))+ }
string_content = @{ (string_raw | string_escape | string_interpolate_escape)* }
string_literal = { "\"" ~ string_content ~ "\"" }

boolean_true  = { "true" }
boolean_false = { "false" }
boolean_literal =  @{ boolean_true | boolean_false }
constant_literal = @{ non_empty_identifier }

// ######################################
// Expression support
// ######################################

function = { non_empty_identifier ~ "(" ~ (argument_value ~ ("," ~ argument_value)*)? ~ ")" }
array_expression = { "[" ~ expression ~ ( "," ~ expression )* ~ "]" }
expression = { array_expression | function | numeric_literal | string_literal | boolean_literal | constant_literal }

// ######################################
// Arguments
// ######################################
argument_name = { (!":" ~ non_empty_identifier)+ }
argument_value = { expression }
argument = { (argument_name ~ ":" ~ argument_value) }

// ######################################
// Directives
// ######################################
directive_arguments = { "(" ~ (((argument | argument_value) ~ ("," ~ argument)*)?) ~ ")" }
// This is a poor-mans version of namespacing
directive_name = @{ (maybe_empty_identifier ~ ".")? ~ maybe_empty_identifier }
// A directive either has one unnamed argument or any number of named arguments or no argument.
directive = { (directive_name ~ directive_arguments | directive_name) }
block_level_directive = { "@@" ~ directive ~ NEWLINE }

// ######################################
// Field declarations
// ######################################
base_type = { non_empty_identifier } // Called base type to not conflict with type rust keyword
list_type = { non_empty_identifier ~ "[]" }
optional_type = { non_empty_identifier ~ "?" }
unsupported_optional_list_type = { non_empty_identifier ~ "[]" ~ "?" }
legacy_required_type = { non_empty_identifier ~ "!" }
legacy_list_type = { "[" ~ non_empty_identifier ~ "]" }

// Pest is greedy, order is very important here.
field_type = { unsupported_optional_list_type | list_type | optional_type | legacy_required_type | legacy_list_type | base_type }

// Field
// TODO: We want to force a line break after a field declaration.
// For this, we have to rely on pests new '-' operator.
// Progress tracked here: https://github.com/pest-parser/pest/issues/271

field_declaration = { doc_comment_and_new_line* ~ non_empty_identifier ~ LEGACY_COLON? ~ (field_type ~ ( "@" ~ directive )+ | field_type)? ~ doc_comment? ~ NEWLINE }

// ######################################
// Custom type declarations
// ######################################
type_declaration = { doc_comment_and_new_line* ~ TYPE_KEYWORD ~ non_empty_identifier ~ "=" ~ (base_type ~ ( "@" ~ directive )+ | base_type)  }

// ######################################
// Model declarations
// ######################################
model_declaration = { (UNTIL_END_OF_LINE | doc_comment_and_new_line)* ~ (MODEL_KEYWORD | TYPE_KEYWORD) ~ non_empty_identifier ~ BLOCK_OPEN ~ ( field_declaration | ( "@@" ~ directive ) | NEWLINE | doc_comment_and_new_line)* ~ BLOCK_CLOSE }

// ######################################
// Enum declarations
// ######################################
enum_field_declaration = { doc_comment_and_new_line* ~ (non_empty_identifier ~ ( "@" ~ directive )+ | non_empty_identifier) ~ doc_comment? ~ NEWLINE }
enum_declaration = { doc_comment_and_new_line* ~ ENUM_KEYWORD ~ non_empty_identifier ~ BLOCK_OPEN ~ (enum_field_declaration | block_level_directive | NEWLINE | doc_comment_and_new_line)* ~ BLOCK_CLOSE }

// ######################################
// Source block
// ######################################
key_value = { non_empty_identifier ~ "=" ~ expression ~ NEWLINE }
source_block = { doc_comment_and_new_line* ~ DATASOURCE_KEYWORD ~ non_empty_identifier ~ BLOCK_OPEN ~ (key_value | doc_comment | NEWLINE)* ~ BLOCK_CLOSE }

// ######################################
// Generator block
// ######################################
generator_block = { doc_comment_and_new_line* ~ GENERATOR_KEYWORD ~ non_empty_identifier ~ BLOCK_OPEN ~ (key_value | doc_comment | NEWLINE)* ~ BLOCK_CLOSE }

arbitrary_block = { doc_comment_and_new_line* ~ non_empty_identifier ~ BLOCK_OPEN ~ ((!BLOCK_CLOSE ~ ANY) | NEWLINE)* ~ BLOCK_CLOSE }

// ######################################
// Datamodel
// ######################################
datamodel = { SOI ~ NEWLINE* ~ (((arbitrary_block | model_declaration | enum_declaration | source_block | generator_block | type_declaration | doc_comment) ~ NEWLINE*) | CATCH_ALL)* ~ EOI }

// ######################################
// String Interpolation
// Called seperatedly, but falls back
// to expression.
// ######################################
// We can safely assume that our strings are stripped of their "s and
// that strings do not contain new lines.

// Greedy match escaped interpolation or any char. Do not match interpolation.
string_any = @{ ANY }
string_escaped_interpolation = @{ "\\"  ~ INTERPOLATION_START }
// String is marked as compound atomic. We do not allow whitespace or similar.
string_interpolated = ${ SOI ~ (
                            // This is basically everything except an expression, using the escape trick from above.
                            (!(INTERPOLATION_START) ~ ( string_escaped_interpolation | string_any))+ |
                            // This is an expression. It's no more atomic.
                            string_interpolate_escape
                        )* ~ EOI }